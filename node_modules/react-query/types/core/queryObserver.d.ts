import { QueryObserverOptions, QueryObserverResult, RefetchOptions, ResultOptions } from './types';
import { Query, Action, FetchOptions } from './query';
import { QueryClient } from './queryClient';
import { Subscribable } from './subscribable';
declare type QueryObserverListener<TData, TError> = (result: QueryObserverResult<TData, TError>) => void;
export interface NotifyOptions {
    cache?: boolean;
    listeners?: boolean;
    onError?: boolean;
    onSuccess?: boolean;
}
export interface ObserverFetchOptions extends FetchOptions {
    throwOnError?: boolean;
}
export declare class QueryObserver<TQueryFnData = unknown, TError = unknown, TData = TQueryFnData, TQueryData = TQueryFnData> extends Subscribable<QueryObserverListener<TData, TError>> {
    options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>;
    private client;
    private currentQuery;
    private currentQueryInitialState;
    private currentResult;
    private currentResultState?;
    private currentResultOptions?;
    private previousQueryResult?;
    private staleTimeoutId?;
    private refetchIntervalId?;
    private trackedProps;
    constructor(client: QueryClient, options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>);
    protected bindMethods(): void;
    protected onSubscribe(): void;
    protected onUnsubscribe(): void;
    shouldFetchOnReconnect(): boolean;
    shouldFetchOnWindowFocus(): boolean;
    destroy(): void;
    setOptions(options?: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>, notifyOptions?: NotifyOptions): void;
    getOptimisticResult(options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>): QueryObserverResult<TData, TError>;
    getCurrentResult(): QueryObserverResult<TData, TError>;
    trackResult(result: QueryObserverResult<TData, TError>): QueryObserverResult<TData, TError>;
    getNextResult(options?: ResultOptions): Promise<QueryObserverResult<TData, TError>>;
    getCurrentQuery(): Query<TQueryFnData, TError, TQueryData>;
    remove(): void;
    refetch(options?: RefetchOptions): Promise<QueryObserverResult<TData, TError>>;
    fetchOptimistic(options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>): Promise<QueryObserverResult<TData, TError>>;
    protected fetch(fetchOptions?: ObserverFetchOptions): Promise<QueryObserverResult<TData, TError>>;
    private executeFetch;
    private updateStaleTimeout;
    private updateRefetchInterval;
    private updateTimers;
    private clearTimers;
    private clearStaleTimeout;
    private clearRefetchInterval;
    protected createResult(query: Query<TQueryFnData, TError, TQueryData>, options: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>): QueryObserverResult<TData, TError>;
    private shouldNotifyListeners;
    updateResult(notifyOptions?: NotifyOptions): void;
    private updateQuery;
    onQueryUpdate(action: Action<TData, TError>): void;
    private notify;
}
export {};
